* dida.el - 在 Emacs 中与滴答清单(Dida365)同步

Dida.el 是一个 Emacs 插件，旨在通过滴答清单（Dida365）官方提供的 API，实现 Emacs Org mode 与滴答清单之间的数据同步。

本插件依赖于以下 Emacs 包：
- [[https://github.com/alphapapa/plz.el][plz]]: 用于发送 HTTP 请求。
- [[https://github.com/magnars/s.el][s.el]]: 用于字符串处理。

** 特性 (Features)
- *双向同步* ：通过独立的 =fetch= (拉取) 和 =push= (推送) 命令，实现与滴答清单的双向同步。具体支持的同步指令：覆盖本地、删除任务、更新任务。 *不支持新建任务* 
- *Org 格式映射* ：
  - 滴答清单的“清单(Project)”映射为 Org 文件的一级标题。
  - “任务(Task)”映射为二级标题。
  - 支持任务状态 (=TODO= / =DONE=)、优先级 (=[#A]=, =[#B]= , =[#C]= )、内容/备注。
  - 支持任务的日期 (=SCHEDULED=) 和重复属性。
- *安全认证* ：使用标准的 OAuth2.0 协议进行授权，确保账户安全。
- async方式push，不阻塞emacs

** 安装 (Installation)
推荐使用 =use-package= 进行管理。请确保您已经安装了 =plz= 和 =s.el= 。

#+BEGIN_SRC emacs-lisp
;; 确保依赖已安装
(use-package plz :ensure t)

(use-package dida :demand t
  :vc (:url "git@github.com:TomoeMami/dida"
            :rev :newest))

#+END_SRC

** 配置 (Configuration)
在使用前，您需要完成以下三个步骤的配置。

*** 第一步：申请 Dida365 API 凭证

1. 访问 [[https://dida365.com/developers][滴答清单开放平台]] 并登录您的账户。
2. 创建一个新的应用。
3. 在应用设置中，您需要填写 *OAuth Redirect URI* 。为了使本插件正常工作，请务必将其设置为：
   #+BEGIN_EXAMPLE
   http://localhost:1145
   #+END_EXAMPLE
4. 创建成功后，您会得到应用的 =Client ID= 和 =Client Secret= 。请将它们妥善保管。

*** 第二步：在 Emacs 中设置变量

将您在上一步获得的凭证和您希望用于同步的本地 Org 文件路径填入 Emacs 配置中。

#+BEGIN_SRC emacs-lisp
(use-package dida :demand t
  :vc (:url "git@github.com:TomoeMami/dida"
            :rev :newest)
  :config
  (setq dida-client-id "YOUR CLIENT ID")
  (setq dida-client-secret "YOUR SECRET")
  (setq dida-sync-file "path/to/your/dida/file"))
#+END_SRC

*** 第三步：授权

首次使用时，您需要对本应用进行授权，以获取访问令牌 (Token)。

1.  在 Emacs 中运行命令 =M-x dida-authorize= 。
2.  Emacs 会自动打开您的默认浏览器，并跳转到滴答清单的授权页面。
3.  请在该页面登录并点击“授权”。
4.  授权成功后，浏览器会跳转到一个本地页面 (localhost:1145)，并显示 "Code copied to kill-ring..."。同时，授权所需的 =code= 已被复制到您的系统剪贴板。
5.  切回 Emacs，在 minibuffer 的提示 "请粘贴code: " 后，使用 =C-y= (yank) 粘贴 =code= 并回车。
6.  如果一切顺利，您会看到 "验证成功！" 的消息。您的访问令牌会被保存在 =~/.emacs.d/didatoken= (默认路径) 文件中，插件会自动处理后续的令牌刷新。

** 使用 (Usage)
为方便使用，建议参考以下设置：

#+begin_src elisp
(use-package dida :demand t
  :vc (:url "git@github.com:TomoeMami/dida"
            :rev :newest)
  :config
  (setq dida-client-id "YOURCLIENT ID")
  (setq dida-client-secret "YOUR SECRET")
  (setq dida-sync-file "path/to/your/dida/file")
  (run-with-idle-timer 60 t #'dida-fetch)
  (add-hook 'org-trigger-hook #'dida-push)
  (add-hook 'after-init-hook #'dida-fetch))

;; 这里使用了doct配置'org-capture-templates'
;; https://github.com/progfolio/doct
(use-package doct
  :demand t
  :autoload doct)
(setq org-capture-templates
      (doct '(;; 用于refile到dida.org的'phone'清单下最新文件
              ("Dida-Refile" :keys "d"
               :file dida-sync-file
               :headline "Phone"
               :template ("* TODO %?")
               :before-finalize dida-create
               ))))
#+end_src

** 个人用例
[2026-01-19 周一 22:28]：直接调用 =org-capture= 并将任务输入到指定位置的函数。
*** 自定义dida相关函数
#+begin_src elisp
(use-package dida :demand t
  :vc (:url "git@github.com:TomoeMami/dida"
            :rev :last-release)
  :config
  (setq dida-client-id "YOUR-CLIENT-ID")
  (setq dida-client-secret "YOUR-CLIENT-SECRET")
  (defun dida-simple-task (task)
    (let* ((id (alist-get 'id task))
           (pid (alist-get 'projectId task))
           (isallday (alist-get 'isAllDay task))
           (title (alist-get 'title task ))
           (content (alist-get 'content task ))
           (status (alist-get 'status task))
           (due-date (alist-get 'dueDate task))
           (priority (alist-get 'priority task))
           (repeatflag (alist-get 'repeatFlag task))
           (deadline-or-scheduled "SCHEDULED: ")
           (h-m (if (eq isallday ':json-false) " %H:%M" "")))
      (concat (if (= status 2) "DONE" "TODO") " " title
              (when due-date
               (concat "\n" deadline-or-scheduled
                       (format-time-string
                        (concat "<%Y-%m-%d %a"
                                h-m 
                                ">")
                        (date-to-time due-date))))
              (when content
                (concat "\n" content "\n")))))
  (defun dida-cut ()
    "从dida获取所有任务并删除云端任务."
    (interactive)
    (unless (dida--check-token)
      (dida-authorize))
    (let ((projects (dida-get-user-project))
          (result))
      (dolist (project projects)
        (let* ((project-id (alist-get 'id project))
               (project-name (alist-get 'name project))
               (project-data (dida-get-project-by-id-with-data project-id))
               (tasks (append (alist-get 'tasks project-data) nil)))
          ;; Insert all tasks under this project
          (dolist (task tasks)
            (setf result (concat result "* " (dida-simple-task task)))
            (dida-complete-task project-id (alist-get 'id task)))))
      result))
#+end_src
*** 配置doct模板
注意，这里我们使用了 =(keyboard-quit)= 函数，这个函数会打断当前进行的系列函数，所以不要把这个 =(org-capture nil "d")= 放进任何hook里。幸运的是我们一般也不需要把他们放进hook中，只需要定时执行拉取就好了。
#+begin_src elisp
(setq org-capture-templates
      (doct '(("Dida Sync" :keys "d"
               ;这里改成你平常用的agenda files之一路径
               :file my-org-timeline
               ;; 使用你常用的定位函数，可忽略
               :function org-reverse-datetree-goto-date-in-file
               ;; 动态调用选择函数获取内容
               :template (lambda () (let ((result (dida-cut)))
                             (if (and result (stringp result))
                                 result
                               ;;没有内容就默默退出吧孩子
                               (keyboard-quit))))
               ;; 捕获后立即完成，不需要手动按 C-c C-c (可选)
               :immediate-finish t)
              )))
#+end_src
*** 定期执行
#+begin_src elisp
;;每60秒执行一次
(run-with-idle-timer 60 t #'(lambda () (org-capture nil "d")))
;;启动后稍等10秒执行一次
(run-at-time 10 nil #'(lambda () (org-capture nil "d")))
#+end_src


这样一来，在启动后或闲置60秒后，会拉取云端覆盖本地文件；
在任务的todo状态改变时，如果变为了DONE，则会将该任务在云端标记为完成；任何其他行为（包括重复设置为TODO）都会触发一次更新，将本地该任务的相关设置同步到云端。
使用org-capture时，可以在将任务添加到 ~dida.org~ 的 ~Phone~ 清单后，自动上传到滴答清单。

